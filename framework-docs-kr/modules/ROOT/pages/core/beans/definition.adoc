[[beans-definition]]
= 빈(Bean) 개요

스프링 IoC 컨테이너는 하나 이상의 빈을 관리합니다.
이러한 빈들은 컨테이너에서 설정한 구성 정보에 의해 만들어집니다.
(예를 들어, XML 형식에서 `<bean/>`로 정의된 것들입니다.)

컨테이너 내부에서 이러한 빈들은 `BeanDefinition` 객체로 표현됩니다.
그리고 이 객체는 (다른 정보들 중에서도) 다음의 메타정보를 포함하고 있습니다.

* 패키지로 정의된 클래스 이름: 일반적으로 정의된 빈의 실제 구현 클래스를 의미합니다.
* 빈의 행동 구성 요소는 컨테이너 내에서 빈이 어떻게 동작해야하는지를 말합니다. (범위, 생명주기 콜백 등)
* 빈이 작업을 수행하기 위해 필요로 하는 다른 빈들에 대한 참조가 있습니다. 이러한 참조는 '협력자' 또는 '의존성'이라고도 불립니다.
* 새로 생성된 객체에 설정할 기타 구성 설정입니다. 예를 들어, 커넥션 풀을 관리하는 빈에서 풀의 크기 제한이나 사용하는 연결 개수와 같은 것들이 있습니다.

This metadata translates to a set of properties that make up each bean definition.
The following table describes these properties:
이 메타정보는 각 빈 정의를 구성하는 일련의 속성들로 변환됩니다.
다음 표는 이 속성에 대한 설명입니다.

[[beans-factory-bean-definition-tbl]]
.The bean definition
|===
| 속성| 설명

| Class
| xref:core/beans/definition.adoc#beans-factory-class[Instantiating Beans]

| Name
| xref:core/beans/definition.adoc#beans-beanname[Naming Beans]

| Scope
| xref:core/beans/factory-scopes.adoc[Bean Scopes]

| Constructor arguments
| xref:core/beans/dependencies/factory-collaborators.adoc[Dependency Injection]

| Properties
| xref:core/beans/dependencies/factory-collaborators.adoc[Dependency Injection]

| Autowiring mode
| xref:core/beans/dependencies/factory-autowire.adoc[Autowiring Collaborators]

| Lazy initialization mode
| xref:core/beans/dependencies/factory-lazy-init.adoc[Lazy-initialized Beans]

| Initialization method
| xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[Initialization Callbacks]

| Destruction method
| xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[Destruction Callbacks]
|===

특정 빈을 어떻게 생성할 지에 대한 정보를 포함하고 있는 빈 정의 외에도,
`ApplicationContext` 구현체는 (사용자가 만든) 컨테이너 외부에서 만들어진 기존 객체 등록도 허용합니다.
이는 `getBeanFactory()` 메서드를 통해 ApplicationContext의 `BeanFactory`에 접근하여 수행할 수 있습니다.
그리고 이 메서드는 `DefaultListableBeanFactory` 구현체를 반환합니다.
`DefaultListableBeanFactory`는 `registerSingleton(..)` 와 `registerBeanDefinition(..)`
메서드를 통해 이러한 등록을 지원합니다.
그러나, 일반적인 애플리케이션은 대부분 평범한 빈 정의 메타데이터를 통해 정의된 빈들만 가지고 동작합니다.

[NOTE]
====
빈 메타데이터와 수동으로 제공된 싱글톤 인스턴스는, 컨테이너가 자동 주입 및 기타 내부 조사 단계에서
이들에 대해 적절하게 추론할 수 있도록 가능한 한 빨리 등록되어야 합니다.
기존 메타데이터와 기존 싱글톤 인스턴스를 일정 정도 덮어쓰는 것은 지원되지만,
런타임에 (팩토리에 실시간으로 접근하는 동안에) 새로운 빈을 등록하는 것은 공식적으로 지원되지 않으며,
동시 접근 예외, 빈 컨테이너의 일관성 없는 상태 또는 둘 다를 초래할 수 있습니다.
====



[[beans-beanname]]
== 빈 이름 짓기

모든 빈은 하나 이상의 식별자를 가지고 있습니다.
이 식별자는 빈을 호스팅하고 있는 컨테이너 내에서 반드시 유일해야 합니다.
하나의 빈은 보통 하나의 식별자를 갖습니다.
그러나, 만약 하나보다 많은 식별자를 가져야한다면, 그 나머지는 별칭(alias)으로 선언할 수 있습니다.

XML 기반의 구성 메타데이터에서는 `id` 애트리부트, `name` 애트리부트 또는 둘 다 사용하여 빈의 식별자를 지정할 수 있습니다.
`id` 애트리부트는 정확히 하나의 `id`를 지정할 수 있습니다.
전통적으로, 이 이름은 영숫자입니다. ('myBean', 'someService', 등)
하지만, 특수한 기호 또한 포함될 수 있습니다.
빈에게 또 다른 별칭을 부여하고 싶다면, `name` 애트리부트에서 콤파(`,`), 세미콜론(`;`) 또는 공백으로 구분하여 지정할 수 있습니다.
`id` 애트리부트는 `xsd:string` 타입으로 정의되어 있지만, 빈 `id` 유일성은 XML 파서가 아닌 컨테이너에 의해서 강제됩니다.

빈에 대한 `name` 또는 `id`를 제공할 필요는 없습니다.
`name` 또는 `id`를 명시적으로 제공하지 않으면, 컨테이너가 빈에 대해 유일한 이름을 생성합니다.
그러나, 만약 `ref` 엘리먼트 또는 서비스 로케이터 스타일 조회를 사용하여 이름으로 빈을 참조하기를 원한다면,
반드시 이름을 제공해야합니다.
이름을 제공하지 않는 이유는
xref:core/beans/dependencies/factory-properties-detailed.adoc#beans-inner-beans[inner beans] 과
xref:core/beans/dependencies/factory-autowire.adoc[autowiring collaborators] 를
사용하는 것과 관련이 있습니다.

.빈 이름 컨밴션
****
빈을 명명할 때 컨밴션은 인스턴스의 필드 이름에 대해 일반적인 자바 컨밴션을 따릅니다.
즉, 빈 이름은 소문자로 시작하여 이후는 카멜 케이스입니다.
예를들어, `accountManager`, `accountService`, `userDao`, `loginController` 등의 이름이 포함됩니다.

빈을 일관되게 명명하는 것은 구성을 더 쉽게 읽고 이해할 수 있습니다.
또한, Spring AOP를 사용한다면, 이름으로 빈 집합에 어드바이스를 적용할 때 더욱 큰 힘을 발휘합니다.
****

NOTE: 클래스패스에서 컴포넌트 스캐닝을 할 때, 이름이 지정되지 않은 컴포넌트에 대해 스프링은 앞서 설명된 규칙을 따라 빈 이름을 생성합니다:
기본적으로 클래스 이름을 가져와서 첫 글자를 소문자로 변경합니다.
하지만, (이례적인) 특별한 경우로 첫 번째와 두 번째 글자가 모두 대문자인 경우에는 원래의 대소문자가 유지됩니다.
이 규칙은 `java.beans.Introspector.decapitalize` 에 의해 정의된 것과 동일한 규칙입니다(스프링이 여기서 사용하는 바입니다).


[[beans-beanname-alias]]
=== 빈 정의 외부에서 빈에 별칭 지정하기

빈 정의 내에서 `id` 애트리부트에 의해 지정된 하나의 이름과 `name` 애트리부트에서 다른 여러 개의 이름의 조합을 사용하여
빈에 대한 이름을 하나 이상 제공할 수 있습니다.
이 이름들은 동일한 빈에 대한 동등한 별칭이 될 수 있으며, 애플리케이션의 각 컴포넌트가 그 컴포넌트 자체에
특정한 빈 이름을 사용하여 공통 의존성을 참조할 수 있도록 하는 등 일부 상황에서 유용합니다.

그러나, 빈이 실제로 정의된 곳에서 모든 별칭을 지정하는 것만으로는 항상 충분하지 않습니다.
때로는 다른 곳에서 정의된 빈에 대해 별칭을 도입하고 싶을 수 있습니다.
이는 대규모 시스템에서 흔히 발생하는 경우로, 구성이 각 하위 시스템별로 분할되며,
각 하위 시스템이 자신만의 객체 정의 세트를 가지고 있는 상황입니다.
XML 기반 구성 메타데이터에서는 `<alias/>` 요소를 사용하여 이를 달성할 수 있습니다.
다음 예제는 이를 수행하는 방법을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="fromName" alias="toName"/>
----

위 예제에서는 `fromName` 으로 명명된 빈(동일한 컨테이너 내에서)은 별칭이 정의된 이후에 `toName` 으로도 참조될 수 있습니다.

예를 들어, 하위 시스템 A에 대한 구성 메타정보는 `subsystemA-dataSource` 라는 이름으로 DataSource를 참조할 수 있습니다.
하위 시스템 B에 대한 구성 메타정보는 `subsystemB-dataSource` 라는 이름으로 DataSource를 참조할 수 있습니다.
이 하위시스템 두 개를 사용하는 메인 애플리케이션을 구성할 때, 메인 애플리케이션은 `myApp-dataSource` 라는 이름으로 DataSource를 참조할 수 있습니다.
같은 객체에 대해서 세 개의 이름으로 모두 참조하도록 하려면, 구성 메타정보에 다음과 같은 별칭 정의를 추가할 수 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
	<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
----

이제 각 컴포넌트와 메인 애플리케이션은 고유한 이름을 통해 dataSource를 참조할 수 있으며,
다른 정의와 충돌하지 않도록 보장됩니다(사실상 네임스페이스를 만듭니다).
그러나, 이들은 동일한 빈을 참조합니다.


.Java-configuration
****
만약 자바 구성을 사용한다면, `@Bean` 애노테이션을 사용하여 별칭을 제공할 수 있습니다.
세부 내용은 xref:core/beans/java/bean-annotation.adoc[Using the `@Bean` Annotation]을 참조하십시오.
****



[[beans-factory-class]]
== 빈 생성하기

빈 정의는 사실상 하나 이상의 객체를 생성하기 위한 레시피입니다.
컨테이너는 요청이 있을 때 명명된 빈에 대해서 이 레시피를 살펴보고,
해당 빈 정의에 의해 캡슐화된 구성 메타정보를 사용하여 실제 객체를 생성하거나 획득합니다.

XML 기반 구성 메타정보를 사용한다면, `<bean/>` 엘리먼트의 `class` 애트리부트에 생성될 객체의 타입(또는 클래스)을 지정합니다.
이 `class` 애트리부트(내부적으로는 `BeanDefinition` 인스턴스의 `Class` 속성)는 일반적으로 필수입니다.
(예외사항은 xref:core/beans/definition.adoc#beans-factory-class-instance-factory-method[Instantiation by Using an Instance Factory Method] and xref:core/beans/child-bean-definitions.adoc[Bean Definition Inheritance]
를 살펴볼 수 있습니다.)
`Class` 속성은 다음 두 가지 방법 중 하나로 사용할 수 있습니다:

* 일반적으로, 컨테이너가 직접 리플렉션을 통해 빈의 생성자를 호출하여 빈을 생성하는 경우,
new 연산자를 사용한 자바 코드와 어느 정도 동등하게, 생성될 빈 클래스를 지정합니다.
* 객체를 생성하기 위해 호출하는 `static` 팩토리 메서드가 포함된 실제 클래스를 지정합니다.
이렇게 컨테이너가 `static` 팩토리 메서드를 호출하여 빈을 생성하는 경우는 흔하지는 않습니다.
`static` 팩토리 메서드의 호출로부터 반환된 객체 타입은 동일한 클래스 또는 완전히 다른 클래스일 수 있습니다.

.중첩된 클래스 이름
****
중첩 클래스에 대한 빈 정의를 구성하고 싶다면, 중첩 클래스의 바이너리 이름이나 소스 이름 중 하나를 사용할 수 있습니다.

예를 들어, `com.example` 패키지에 `SomeThing`이라는 클래스가 있고, 이 `SomeThing` 클래스에
`static` 중첩 클래스인 `OtherThing`이 있다면, 이들은 달러 기호(`$`) 또는 점(`.`)으로 구분될 수 있습니다.
따라서 빈 정의의 `class` 애트리부트의 값은 `com.example.SomeThing$OtherThing`
또는 `com.example.SomeThing.OtherThing`가 될 것입니다.
****


[[beans-factory-class-ctor]]
=== 생성자를 이용한 인스턴스화

생성자에 접근하여 빈을 생성할 때, 모든 일반적인 클래스는 스프링에서 사용할 수 있으며 호환됩니다.
즉, 개발 중인 클래스는 특정 인터페이스를 구현할 필요가 없으며 특정한 방식으로 코딩할 필요도 없습니다.
단순히 빈 클래스를 지정하는 것만으로 충분합니다.
하지만, 특정 빈에 사용하는 IoC의 유형에 따라 기본 생성자(빈 생성자)가 필요할 수 있습니다.

스프링 IoC 컨테이너는 관리하길 원하는 거의 모든 클래스를 관리할 수 있습니다.
JavaBeans만 관리하는 것에 한정되지는 않습니다.
대부분의 스프링 사용자는 컨테이너 내의 프로퍼티에 모델링된 적절한 세터와 게터를 가진 기본 생성자(인자 없는 생성자)만 있는 실제 JavaBeans를 선호합니다.
컨테이너 내에 더 이국적으로 빈 스타일이 아닌 클래스도 가질 수 있습니다.
예를 들어, JavaBean 사양을 전혀 따르지 않는 레거시 연결 풀을 사용해야 하는 경우, 스프링은 그것도 관리할 수 있습니다.

XML 기반 구성 메타데이터를 사용하여 빈 클래스를 다음과 같이 지정할 수 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean"/>

	<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
----

생성자에 인자를 제공하는 메커니즘(필요한 경우)과 객체가 구성된 후 객체 인스턴스 속성을 설정하는 방법에 대한 자세한 내용은
xref:core/beans/dependencies/factory-collaborators.adoc[의존성 주입(Injecting Dependencies)]을 참조하십시오.


[[beans-factory-class-static-factory-method]]
=== 정적 팩토리 메서드를 이용한 인스턴스화

정적 팩토리 메서드로 생성하는 빈을 정의할 때, `class` 애트리부트를 사용하여 `static` 팩토리 메서드를 포함하는 클래스를 지정하고,
`factory-method` 애트리부트를 사용하여 팩토리 메서드 자체의 이름을 지정합니다.
이 메서드를 호출하고(인자를 추가할 수도 있습니다. 이는 나중에 설명합니다) 실제 객체를 반환할 수 있어야 합니다.
그리고 이후에는 이 객체가 생성자를 통해 생성된 것처럼 취급됩니다.
이러한 빈 정의의 사용 사례 중 하나는 레거시 코드에서 `static` 팩토리를 호출하는 것입니다.

아래 예제의 빈 정의는 팩토리 메서드를 호출하여 생성될 빈을 지정합니다.
이 정의는 반환된 객체의 타입(클래스)을 지정하지 않고, 대신 팩토리 메서드를 포함하는 클래스를 지정합니다.
이 예제에서 `createInstance()` 메서드는 `static` 메서드여야 합니다.
다음 예제는 팩토리 메서드를 지정하는 방법을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="clientService"
		class="examples.ClientService"
		factory-method="createInstance"/>
----

아래 예제는 앞선 빈 정의가 적용될 클래스를 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class ClientService {
		private static ClientService clientService = new ClientService();
		private ClientService() {}

		public static ClientService createInstance() {
			return clientService;
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class ClientService private constructor() {
		companion object {
			private val clientService = ClientService()
			@JvmStatic
			fun createInstance() = clientService
		}
	}
----
======

(선택적인) 인자를 팩토리 메서드에 제공하고, 팩토리에서 반환된 객체에 대한 속성을 설정하는 메커니즘에 대한 자세한 내용은
xref:core/beans/dependencies/factory-properties-detailed.adoc[의존성 주입(Injecting Dependencies)]을 참조하십시오.


[[beans-factory-class-instance-factory-method]]
=== 인스턴스 팩토리 메서드를 이용한 인스턴스화

xref:core/beans/definition.adoc#beans-factory-class-static-factory-method[static factory method]를 통해
인스턴스화하는 것과 유사하게, 인스턴스 팩토리 메서드로 인스턴스화하는 것은 컨테이너 내의 기존 빈의 비정적(non-static) 메서드를 호출하여 새로운 빈을 생성합니다.
이 메커니즘을 사용하기 위해서는 `class` 애트리부트를 비워두고, `factory-bean` 애트리부트는
객체를 생성하기 위해 호출될 인스턴스 메서드를 포함하는 현재(또는 부모나 조상) 컨테이너 내의 빈의 이름으로 지정합니다.
아래의 예제는 이와 같은 빈을 어떻게 구성하는지 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- the factory bean, which contains a method called createClientServiceInstance() -->
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>

	<!-- the bean to be created via the factory bean -->
	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>
----

아래 예제는 위 구성 예제에 대응하는 클래스를 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
		}
		fun createClientServiceInstance(): ClientService {
			return clientService
		}
	}
----
======

하나의 팩토리 클래스는 하나 이상의 팩토리 메서드를 가질 수 있습니다. 아래 예제에서 이를 보여주고 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>

	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>

	<bean id="accountService"
		factory-bean="serviceLocator"
		factory-method="createAccountServiceInstance"/>
----

아래 예제는 위 구성 예제에 대응하는 클래스를 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		private static AccountService accountService = new AccountServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}

		public AccountService createAccountServiceInstance() {
			return accountService;
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
			private val accountService = AccountServiceImpl()
		}

		fun createClientServiceInstance(): ClientService {
			return clientService
		}

		fun createAccountServiceInstance(): AccountService {
			return accountService
		}
	}
----
======

이 접근은 팩토리 빈 자체가 의존성 주입(DI)을 통해 스스로 관리되고 구성될 수 있음을 보여줍니다.
xref:core/beans/dependencies/factory-properties-detailed.adoc[Dependencies and Configuration in Detail]를 살펴보십시오.

NOTE: 스프링 문서에서 "factory bean"은 스프링 컨테이너에서 구성되고
xref:core/beans/definition.adoc#beans-factory-class-instance-factory-method[instance] 또는
xref:core/beans/definition.adoc#beans-factory-class-static-factory-method[static] 팩토리 메서드를 통해
객체를 생성하는 빈을 말합니다.
반면, `FactoryBean` (대문자 사용에 주목)은 스프링 특화
xref:core/beans/factory-extension.adoc#beans-factory-extension-factorybean[`FactoryBean`]
구현 클래스를 의미합니다.

[[beans-factory-type-determination]]
=== 빈의 런타임 타입 지정하기

특정 빈의 런타임 유형을 결정하는 것은 간단하지 않습니다.
빈 메타데이터 정의에 명시된 클래스는 초기 클래스 참조일 뿐입니다.
이 클래스는 선언된 팩토리 메서드를 결합하거나 `FactoryBean` 클래스일 수도 있기 때문에 빈의 런타임 타입이 달라질 수 있거나,
인스턴스 수준 팩토리 메서드의 경우 전혀 설정되지 않을 수도 있습니다(대신 지정된 `factory-bean` 이름을 통해 해결됩니다).
추가로, AOP 프록싱은 빈 인스턴스를 인터페이스 기반 프록시로 감싸 대상 빈의 실제 타입을 제한적으로만 노출할 수 있습니다(구현된 인터페이스만).

특정 빈의 실제 런타임 타입을 알아내는 권장 방법은 지정된 빈 이름으로 `BeanFactory.getType`을 호출하는 것입니다.
이는 위에서 언급한 모든 경우를 고려하며, 같은 빈 이름에 대해 `BeanFactory.getBean` 호출이 반환할 객체 타입을 반환합니다.








