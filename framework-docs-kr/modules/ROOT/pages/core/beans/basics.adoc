[[beans-basics]]
= 컨테이너 개요

`org.springframework.context.ApplicationContext` 인터페이스는 스프링 IoC 컨테이너를 나타내고,
이는 빈을 인스턴스화하고, 구성하고, 조합하는 역할을 합니다.
컨테이너는 구성 메타데이터(configuration metadata)를 읽어 어떤 객체를 인스턴스화하고, 구성하고, 조합해야하는지에 대해서 알아냅니다.
이 구성 메타데이터는 XML, 자바 애노테이션 또는 자바 코드로 구현할 수 있습니다.
이를 통해 애플리케이션을 구성하고 있는 객체와 그 객체 사이의 다양한 상호 의존성을 표현할 수 있습니다.

`ApplicationContext` 의 몇몇 구현체들은 스프링에서 제공됩니다. 독립 수행 애플리케이션에서는
{spring-framework-api}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`]
또는 {spring-framework-api}/context/support/FileSystemXmlApplicationContext.html[`FileSystemXmlApplicationContext`]
구현체를 공통으로 생성합니다.
XML은 구성 메타데이터를 구성하기 위해 전통적인 형식의 빈을 가지고 있는 반면에,
XML은 구성 메타데이터를 구성하기 위한 전통적인 방식이었지만, 현재는 자바 애노테이션이나 코드로도 가능합니다.
이러한 추가적인 메타데이터 형식을 명시적으로 사용하기 위해서는 적은 양이지만 XML 설정이 필요합니다.

대부분 애플리케이션 시나리오에서는 스프링 IoC 컨테이너의 인스턴스 하나 이상을 인스턴스화하는데 있어 명시적인 코드가 필요하지는 않습니다.
예를 들어, 웹 애플리케이션 시나리오에서는 일반적으로 애플리케이션의 `web.xml` 파일에서 웹을 설명하는 XML 보일러플레이트 코드로
간단히 8줄 정도면 충분합니다.
(살펴보기 xref:core/beans/context-introduction.adoc#context-create[Convenient ApplicationContext Instantiation for Web Applications])
만약 {spring-site-tools}[Spring Tools for Eclipse](이클립스에 특화된 개발 환경)을 사용한다면,
몇 번의 마우스 클릭 또는 키보드를 치는 걸로 쉽게 이 보일러플레이트 설정을 만들 수 있습니다.

아래 다이어그램 그림은 스프링이 어떻게 동작하는지 추상화된 모습입니다.
애플리케이션 클래스들은 구성 메타데이터를 통해 구성되어 `ApplicationContext` 를 만들고 인스턴스화합니다.
그 후, 완전히 설정되고 실행할 수 있는 시스템 또는 애플리케이션을 사용할 수 있습니다.

.The Spring IoC container
image::container-magic.png[]



[[beans-factory-metadata]]
== 구성 메타데이터

앞서 다이어그램에서 보여주었듯이, 스프링 IoC 컨테이너는 구성 메타데이터의 한 형태를 사용합니다.
이 구성 메타데이터는 애플리케이션 개발자로서 스프링 컨테이너에게 어떻게
애플리케이션의 객체들을 인스턴스화하고, 구성하고, 조립하도록 지시해야하는지 알려줍니다.

구성 메타데이터는 전통적으로 간단하고 직관적인 XML 형식을 제공됩니다.
이 장에서는 주로 XML 형식을 사용하여 스프링 IoC 컨테이너의 핵심 개념과 기능을 전달할 것입니다.

참고: 구성 메타데이터 형태로 XML 기반 메타데이터만이 사용되는 것은 아닙니다.
스프링 IoC 컨테이너 자체는 구성 메타데이터가 실제로 어떤 형식으로 작성되었는지와는 완전히 분리되어 있습니다.
현재 많은 개발자들은 스프링 애플리케이션에서 xref:core/beans/java.adoc[자바 기반 구성]을 선택하고 있습니다.

스프링 컨테이너에서 다른 메타데이터 형식에 대한 정보는 아래를 참고하세요.

* xref:core/beans/annotation-config.adoc[애노테이션 기반 구성]: 애노테이션 기반 구성 메타데이터로 빈을 정의합니다.
* xref:core/beans/java.adoc[자바 기반 구성]: XML 파일 대신 자바를 사용하여 애플리케이션 외부에 빈을 정의합니다.
이 기능을 사용하기 위해서는 {spring-framework-api}/context/annotation/Configuration.html[`@Configuration`],
{spring-framework-api}/context/annotation/Bean.html[`@Bean`],
{spring-framework-api}/context/annotation/Import.html[`@Import`],
and {spring-framework-api}/context/annotation/DependsOn.html[`@DependsOn`] 애노테이션을 참고하세요.

스프링 구성은 컨테이너가 관리하는 빈 정의를 적어도 하나 이상 포함하고 있습니다.
XML 기반 구성 메타데이터는 파일 내에 최상위 `<beans/>` 요소 안에 `<bean/>` 요소로 이러한 빈들을 구성합니다.
자바 구성은 일반적으로 `@Configuration` 클래스 내의 `@Bean` 애노테이션된 메소드를 사용합니다.

이 빈 정의는 애플리케이션을 구성한 실제 객체와 일치합니다.
일반적으로, 서비스 계층 객체, 리포지토리 또는 DAO(Data Access Object)와 같은 영속 계층 객체,
웹 컨트롤러와 같은 표현 계층 객체 그리고 JPA `EntityManagerFactory`, JMS queues 와 같은
인프라 계층 객체 등 4개의 계층에 대해 정의합니다.
일반적으로, 컨테이너에서 세부적인 도메인 객체에 대해서는 설정하지는 않습니다.
왜냐하면, 도메인 객체를 생성하고 저장하는 책임은 리포지토리와 비즈니스 로직이 담당하기 때문입니다.

아래 예제는 XML 기반 구성 메타데이터의 기본 구조를 보여줍니다.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="..." class="..."> <1> <2>
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<bean id="..." class="...">
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions go here -->

	</beans>
----

<1> `id` 애트리부트는 문자열이고, 각각의 빈 정의를 구분하는 값으로 사용됩니다.
<2> `class` 애트리부트는 빈의 타입을 정의하고 완전한 클래스 이름으로 사용됩니다.

`id` 애트리부트는 서로 협력하고 있는 여러 객체들을 참조하는데 사용할 수도 있습니다.
XML에서 이러한 객체들을 참조하는 방법은 위 XML 예제에서 보여주고 있지는 않습니다.
좀 더 자세한 내용은 xref:core/beans/dependencies.adoc[Dependencies] 여기를 살펴보세요.

[[beans-factory-instantiation]]
== 컨테이너 인스턴스화

`ApplicationContext` 생성자에 제공된 위치 경로 또는 경로들은 리소스 문자열로,
컨테이너가 로컬 파일 시스템, 자바의 `CLASSPATH` 등과 같은 다양한 외부 리소스에
구성 메타데이터를 저장할 수 있도록 합니다.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")
----
======

[NOTE]
====
스프링 IoC 컨테이너에 대해서 배우고 나면, 스프링의 `Resource`
(xref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-reactor-resources[Resources]에 설명하는)
추상화에 대해서 좀 더 궁금해질 것입니다.
이는 URI에 정의된 위치에서 InputStream을 읽는 편리한 매커니즘을 제공합니다.
특히, `Resource` 경로들은
xref:core/resources.adoc#resources-app-ctx[Application Contexts and Resource Paths]
에서 설명되었듯이, 애플리케이션 컨텍스트를 생성하기 위해 주로 사용됩니다.
====

다음 예제는 `(services.xml)` 구성 파일에 있는 서비스 계층의 객체들을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- services -->

		<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
			<property name="accountDao" ref="accountDao"/>
			<property name="itemDao" ref="itemDao"/>
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for services go here -->

	</beans>
----

다음 예제는 `daos.xml` 파일에 있는 데이터 접근 객체들을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="accountDao"
			class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for data access objects go here -->

	</beans>
----

In the preceding example, the service layer consists of the `PetStoreServiceImpl` class
and two data access objects of the types `JpaAccountDao` and `JpaItemDao` (based
on the JPA Object-Relational Mapping standard). The `property name` element refers to the
name of the JavaBean property, and the `ref` element refers to the name of another bean
definition. This linkage between `id` and `ref` elements expresses the dependency between
collaborating objects. For details of configuring an object's dependencies, see
xref:core/beans/dependencies.adoc[Dependencies].

앞선 예제에서 서비스 계층은 `PetStoreServiceImpl` 클래스와 `JpaAccountDao`, `JpaItemDao`
두 개의 데이터 접근 객체 타입(기본적인 JPA 객체 관계 매핑) 으로 이루어져 있습니다.
`property name` 엘리먼트는 자바 빈 프로퍼티의 이름에 해당되고,
`ref` 엘리먼트는 또 다른 빈 정의의 이름과 연결됩니다.
`id`와 `ref` 두 엘리먼트와의 결합은 서로 협력하는 객체들 사이의 의존성을 표현합니다.
객체의 의존성을 설정하는 데 있어서 좀 더 자세한 내용은 xref:core/beans/dependencies.adoc[Dependencies]
를 참고하세요.


[[beans-factory-xml-import]]
=== XML 기반 구성 메타데이터 구성하기

빈 정의는 여러 XML 파일에 나눠 정의하는 것이 유용할 수가 있습니다.
각각의 XML 구성 파일은 보통 아키텍터의 논리적인 계층 또는 모듈을 표현할 수 있습니다.

나눠져있는 각각의 XML 부분에 정의되어 있는 빈 정의들을 모두 가져오기 위해서 애플리케이션 컨텍스트 생성자를 사용할 수 있습니다.
이 생성자는 여러 개의 `Resource` 위치들을 가져오는데,
이는 xref:core/beans/basics.adoc#beans-factory-instantiation[previous section] 여기서 확인하였었습니다.
또 다른 방법으로는, 하나 이상의 `<import/>` 앨리먼트를 정의해서 다른 파일의 빈 정의를 가져올 수도 있습니다.
아래 예제는 어떻게 `<import/>`을 사용하는지 보여주고 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="services.xml"/>
		<import resource="resources/messageSource.xml"/>
		<import resource="/resources/themeSource.xml"/>

		<bean id="bean1" class="..."/>
		<bean id="bean2" class="..."/>
	</beans>
----

앞선 예제에서는 외부 빈 정의를 총 3개의 파일에서 가져오고 있습니다:
바로 `services.xml`, `messageSource.xml`, 그리고 `themeSource.xml` 입니다.
이 모든 위치 경로는 import를 사용하여 정의하고 있는 파일과는 상대적인 위치에 있습니다.
가령 `services.xml`는 같은 디렉토리 또는 클래스패쓰 위치에 존재해야 합니다.
`messageSource.xml`와 `themeSource.xml`는 둘 다
import하고 있는 파일 아래의 `resources` 위치 안에 있어야 합니다.
보시다시피, 경로의 맨 처음 '/'는 무시됩니다.
그러나 이러한 경로는 상대적이므로, '/'는 사용하지 않는 것이 더 좋습니다.
최상위 `<beans/>` 앨리먼트 내의 import된 파일의 내용은 스프링 스키마를 따른 유효한 XML 빈 정의여야 합니다.

[참고]
====
상대 경로 "../"를 사용하여 상위 디렉토리에 파일을 참조하는 것은 가능하지만 추천하지는 않습니다.
만약 이를 사용하게되면 현재 애플리케이션 외부의 파일에 대한 의존성이 생깁니다.
특히, 이러한 참조는 `classpath:` URL에서는 추천하지 않습니다. (예를 들어, `classpath:../services.xml`)
`classpath:`는 런타임 해석 과정에서 "`nearest`" 즉, 가장 가까운 클래스패쓰 루트를 선택하고 그 상위 디렉토리를 찾습니다.
클래스패쓰 설정을 변경하게 되면 전혀 다른 잘못된 디렉토리를 선택하게 할 수도 있습니다.

상대적인 경로 대신에 항상 완전히 충족된 리소스 위치를 사용할 수도 있습니다:
예를 들어, `file:C:/config/services.xml` 또는 `classpath:/config/services.xml`
그러나, 이를 사용하게 되면 애플리케이션의 구성과 특정한 절대 경로 위치가 서로 종속된다는 것을 명심해야 합니다.
그러므로 절대 경로 위치에 대한 간접 참조를 유지하는 것이 일반적으로 바람직합니다.
예를 들어, 런타임에 JVM 시스템 속성을 해석하는 "${...}" 플레이스홀더와 같은 것이 있습니다.
====

네임스페이스는 그 자체로 import를 지정하는 기능을 제공합니다.
일반 빈 정의뿐 아니라, 스프링이 제공하는 여러 XML 네임스페이스 선택지에서 추가적인 구성 기능들이 사용 가능합니다.
예를 들어, `context`와 `util` 네임스페이스가 있습니다.

[[groovy-bean-definition-dsl]]
=== Groovy 빈 정의 DSL

외부화된 구성 메타데이터를 위한 또 다른 예로서, 빈 정의는 Grails 프레임워크에서 알려진 것처럼
스프링의 Groovy 빈 정의 DSL 로도 표현이 가능합니다.
일반적으로, 이러한 구성은 아래 예제에서 구조를 볼 수 있으며, ".groovy" 파일 내에 존재합니다.

[source,groovy,indent=0,subs="verbatim,quotes"]
----
	beans {
		dataSource(BasicDataSource) {
			driverClassName = "org.hsqldb.jdbcDriver"
			url = "jdbc:hsqldb:mem:grailsDB"
			username = "sa"
			password = ""
			settings = [mynew:"setting"]
		}
		sessionFactory(SessionFactory) {
			dataSource = dataSource
		}
		myService(MyService) {
			nestedBean = { AnotherBean bean ->
				dataSource = dataSource
			}
		}
	}
----

이 구성 스타일은 XML 빈 구성과 거의 동일하고 스프링의 XML 구성 네임스페이스와 같은 지원을 받습니다.
또한, 직접 `importBeans`를 사용해서 XML 빈 정의 파일을 추가하는 것을 허용합니다.

[[beans-factory-client]]
== 컨테이너 사용

`ApplicationContext`는 다양한 빈들과 그들의 의존성을 유지하는 레지스트리를 관리할 수 있는 고도화된 팩토리의 인터페이스입니다.
`T getBean(String name, Class<T> requiredType)` 메서드를 사용하면, 정의한 빈의 인스턴스를 찾을 수 있다.

The `ApplicationContext` lets you read bean definitions and access them, as the following
example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	// create and configure beans
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

	// retrieve configured instance
	PetStoreService service = context.getBean("petStore", PetStoreService.class);

	// use configured instance
	List<String> userList = service.getUsernameList();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    import org.springframework.beans.factory.getBean

	// create and configure beans
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

    // retrieve configured instance
    val service = context.getBean<PetStoreService>("petStore")

    // use configured instance
    var userList = service.getUsernameList()
----
======

With Groovy configuration, bootstrapping looks very similar. It has a different context
implementation class which is Groovy-aware (but also understands XML bean definitions).
The following example shows Groovy configuration:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")
----
======

The most flexible variant is `GenericApplicationContext` in combination with reader
delegates -- for example, with `XmlBeanDefinitionReader` for XML files, as the following
example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	GenericApplicationContext context = new GenericApplicationContext();
	new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
	context.refresh();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val context = GenericApplicationContext()
	XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
	context.refresh()
----
======

You can also use the `GroovyBeanDefinitionReader` for Groovy files, as the following
example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	GenericApplicationContext context = new GenericApplicationContext();
	new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
	context.refresh();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val context = GenericApplicationContext()
	GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
	context.refresh()
----
======

You can mix and match such reader delegates on the same `ApplicationContext`,
reading bean definitions from diverse configuration sources.

You can then use `getBean` to retrieve instances of your beans. The `ApplicationContext`
interface has a few other methods for retrieving beans, but, ideally, your application
code should never use them. Indeed, your application code should have no calls to the
`getBean()` method at all and thus have no dependency on Spring APIs at all. For example,
Spring's integration with web frameworks provides dependency injection for various web
framework components such as controllers and JSF-managed beans, letting you declare
a dependency on a specific bean through metadata (such as an autowiring annotation).




