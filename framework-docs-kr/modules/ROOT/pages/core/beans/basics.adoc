[[beans-basics]]
= 컨테이너 개요

`org.springframework.context.ApplicationContext` 인터페이스는 스프링 IoC 컨테이너를 나타내고,
이는 빈을 인스턴스화하고, 구성하고, 조합하는 역할을 합니다.
컨테이너는 설정 메타데이터(configuration metadata)를 읽어 어떤 객체를 인스턴스화하고, 구성하고, 조합해야하는지에 대해서 알아냅니다.
이 설정 메타데이터는 XML, 자바 애노테이션 또는 자바 코드로 구현할 수 있습니다.
이를 통해 애플리케이션을 구성하고 있는 객체와 그 객체 사이의 다양한 상호 의존성을 표현할 수 있습니다.

`ApplicationContext` 의 몇몇 구현체들은 스프링에서 제공됩니다. 독립 수행 애플리케이션에서는
{spring-framework-api}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`]
또는 {spring-framework-api}/context/support/FileSystemXmlApplicationContext.html[`FileSystemXmlApplicationContext`]
구현체를 공통으로 생성합니다.
XML은 설정 메타데이터를 구성하기 위해 전통적인 형식의 빈을 가지고 있는 반면에,
XML은 설정 메타데이터를 구성하기 위한 전통적인 방식이었지만, 현재는 자바 애노테이션이나 코드로도 가능합니다.
이러한 추가적인 메타데이터 형식을 명시적으로 사용하기 위해서는 적은 양이지만 XML 설정이 필요합니다.

대부분 애플리케이션 시나리오에서는 스프링 IoC 컨테이너의 인스턴스 하나 이상을 인스턴스화하는데 있어 명시적인 코드가 필요하지는 않습니다.
예를 들어, 웹 애플리케이션 시나리오에서는 일반적으로 애플리케이션의 `web.xml` 파일에서 웹을 설명하는 XML 보일러플레이트 코드로
간단히 8줄 정도면 충분합니다.
(살펴보기 xref:core/beans/context-introduction.adoc#context-create[Convenient ApplicationContext Instantiation for Web Applications])
만약 {spring-site-tools}[Spring Tools for Eclipse](이클립스에 특화된 개발 환경)을 사용한다면,
몇 번의 마우스 클릭 또는 키보드를 치는 걸로 쉽게 이 보일러플레이트 설정을 만들 수 있습니다.

아래 다이어그램 그림은 스프링이 어떻게 동작하는지 추상화된 모습입니다.
애플리케이션 클래스들은 설정 메타데이터를 통해 구성되어 `ApplicationContext` 를 만들고 인스턴스화합니다.
그 후, 완전히 설정되고 실행할 수 있는 시스템 또는 애플리케이션을 사용할 수 있습니다.

.The Spring IoC container
image::container-magic.png[]



[[beans-factory-metadata]]
== 설정 메타데이터

앞서 다이어그램에서 보여주었듯이, 스프링 IoC 컨테이너는 설정 메타데이터의 한 형태를 사용합니다.
이 설정 메타데이터는 애플리케이션 개발자로서 스프링 컨테이너에게 어떻게
애플리케이션의 객체들을 인스턴스화하고, 설정하고, 조립하도록 지시해야하는지 알려줍니다.

설정 메타데이터는 전통적으로 간단하고 직관적인 XML 형식을 제공됩니다.
이 장에서는 주로 XML 형식을 사용하여 스프링 IoC 컨테이너의 핵심 개념과 기능을 전달할 것입니다.

참고: 설정 메타데이터 형태로 XML 기반 메타데이터만이 사용되는 것은 아닙니다.
스프링 IoC 컨테이너 자체는 설정 메타데이터가 실제로 어떤 형식으로 작성되었는지와는 완전히 분리되어 있습니다.
현재 많은 개발자들은 스프링 애플리케이션에서 xref:core/beans/java.adoc[자바 기반 설정]을 선택하고 있습니다.

스프링 컨테이너에서 다른 메타데이터 형식에 대한 정보는 아래를 참고하세요.

* xref:core/beans/annotation-config.adoc[애노테이션 기반 설정]: 애노테이션 기반 설정 메타데이터로 빈을 정의합니다.
* xref:core/beans/java.adoc[자바 기반 설정]: XML 파일 대신 자바를 사용하여 애플리케이션 외부에 빈을 정의합니다.
이 기능을 사용하기 위해서는 {spring-framework-api}/context/annotation/Configuration.html[`@Configuration`],
{spring-framework-api}/context/annotation/Bean.html[`@Bean`],
{spring-framework-api}/context/annotation/Import.html[`@Import`],
and {spring-framework-api}/context/annotation/DependsOn.html[`@DependsOn`] 애노테이션을 참고하세요.

스프링 설정은 컨테이너가 관리하는 빈 정의를 적어도 하나 이상 포함하고 있습니다.
XML 기반 설정 메타데이터는 파일 내에 최상위 `<beans/>` 요소 안에 `<bean/>` 요소로 이러한 빈들을 설정합니다.
자바 설정은 일반적으로 `@Configuration` 클래스 내의 `@Bean` 애노테이션된 메소드를 사용합니다.

These bean definitions correspond to the actual objects that make up your application.
Typically, you define service layer objects, persistence layer objects such as
repositories or data access objects (DAOs), presentation objects such as Web controllers,
infrastructure objects such as a JPA `EntityManagerFactory`, JMS queues, and so forth.
Typically, one does not configure fine-grained domain objects in the container, because
it is usually the responsibility of repositories and business logic to create and load
domain objects.

이 빈 정의는 애플리케이션을 구성한 실제 객체와 일치합니다.

The following example shows the basic structure of XML-based configuration metadata:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="..." class="..."> <1> <2>
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<bean id="..." class="...">
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions go here -->

	</beans>
----

<1> The `id` attribute is a string that identifies the individual bean definition.
<2> The `class` attribute defines the type of the bean and uses the fully qualified
class name.

The value of the `id` attribute can be used to refer to collaborating objects. The XML
for referring to collaborating objects is not shown in this example. See
xref:core/beans/dependencies.adoc[Dependencies] for more information.



[[beans-factory-instantiation]]
== Instantiating a Container

The location path or paths
supplied to an `ApplicationContext` constructor are resource strings that let
the container load configuration metadata from a variety of external resources, such
as the local file system, the Java `CLASSPATH`, and so on.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")
----
======

[NOTE]
====
After you learn about Spring's IoC container, you may want to know more about Spring's
`Resource` abstraction (as described in
xref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-reactor-resources[Resources])
which provides a convenient mechanism for reading an InputStream from locations defined
in a URI syntax. In particular, `Resource` paths are used to construct applications contexts,
as described in xref:core/resources.adoc#resources-app-ctx[Application Contexts and Resource Paths].
====

The following example shows the service layer objects `(services.xml)` configuration file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- services -->

		<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
			<property name="accountDao" ref="accountDao"/>
			<property name="itemDao" ref="itemDao"/>
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for services go here -->

	</beans>
----

The following example shows the data access objects `daos.xml` file:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="accountDao"
			class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for data access objects go here -->

	</beans>
----

In the preceding example, the service layer consists of the `PetStoreServiceImpl` class
and two data access objects of the types `JpaAccountDao` and `JpaItemDao` (based
on the JPA Object-Relational Mapping standard). The `property name` element refers to the
name of the JavaBean property, and the `ref` element refers to the name of another bean
definition. This linkage between `id` and `ref` elements expresses the dependency between
collaborating objects. For details of configuring an object's dependencies, see
xref:core/beans/dependencies.adoc[Dependencies].


[[beans-factory-xml-import]]
=== Composing XML-based Configuration Metadata

It can be useful to have bean definitions span multiple XML files. Often, each individual
XML configuration file represents a logical layer or module in your architecture.

You can use the application context constructor to load bean definitions from all these
XML fragments. This constructor takes multiple `Resource` locations, as was shown in the
xref:core/beans/basics.adoc#beans-factory-instantiation[previous section]. Alternatively,
use one or more occurrences of the `<import/>` element to load bean definitions from
another file or files. The following example shows how to do so:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="services.xml"/>
		<import resource="resources/messageSource.xml"/>
		<import resource="/resources/themeSource.xml"/>

		<bean id="bean1" class="..."/>
		<bean id="bean2" class="..."/>
	</beans>
----

In the preceding example, external bean definitions are loaded from three files:
`services.xml`, `messageSource.xml`, and `themeSource.xml`. All location paths are
relative to the definition file doing the importing, so `services.xml` must be in the
same directory or classpath location as the file doing the importing, while
`messageSource.xml` and `themeSource.xml` must be in a `resources` location below the
location of the importing file. As you can see, a leading slash is ignored. However, given
that these paths are relative, it is better form not to use the slash at all. The
contents of the files being imported, including the top level `<beans/>` element, must
be valid XML bean definitions, according to the Spring Schema.

[NOTE]
====
It is possible, but not recommended, to reference files in parent directories using a
relative "../" path. Doing so creates a dependency on a file that is outside the current
application. In particular, this reference is not recommended for `classpath:` URLs (for
example, `classpath:../services.xml`), where the runtime resolution process chooses the
"`nearest`" classpath root and then looks into its parent directory. Classpath
configuration changes may lead to the choice of a different, incorrect directory.

You can always use fully qualified resource locations instead of relative paths: for
example, `file:C:/config/services.xml` or `classpath:/config/services.xml`. However, be
aware that you are coupling your application's configuration to specific absolute
locations. It is generally preferable to keep an indirection for such absolute
locations -- for example, through "${...}" placeholders that are resolved against JVM
system properties at runtime.
====

The namespace itself provides the import directive feature. Further
configuration features beyond plain bean definitions are available in a selection
of XML namespaces provided by Spring -- for example, the `context` and `util` namespaces.


[[groovy-bean-definition-dsl]]
=== The Groovy Bean Definition DSL

As a further example for externalized configuration metadata, bean definitions can also
be expressed in Spring's Groovy Bean Definition DSL, as known from the Grails framework.
Typically, such configuration live in a ".groovy" file with the structure shown in the
following example:

[source,groovy,indent=0,subs="verbatim,quotes"]
----
	beans {
		dataSource(BasicDataSource) {
			driverClassName = "org.hsqldb.jdbcDriver"
			url = "jdbc:hsqldb:mem:grailsDB"
			username = "sa"
			password = ""
			settings = [mynew:"setting"]
		}
		sessionFactory(SessionFactory) {
			dataSource = dataSource
		}
		myService(MyService) {
			nestedBean = { AnotherBean bean ->
				dataSource = dataSource
			}
		}
	}
----

This configuration style is largely equivalent to XML bean definitions and even
supports Spring's XML configuration namespaces. It also allows for importing XML
bean definition files through an `importBeans` directive.



[[beans-factory-client]]
== Using the Container

The `ApplicationContext` is the interface for an advanced factory capable of maintaining
a registry of different beans and their dependencies. By using the method
`T getBean(String name, Class<T> requiredType)`, you can retrieve instances of your beans.

The `ApplicationContext` lets you read bean definitions and access them, as the following
example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	// create and configure beans
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

	// retrieve configured instance
	PetStoreService service = context.getBean("petStore", PetStoreService.class);

	// use configured instance
	List<String> userList = service.getUsernameList();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    import org.springframework.beans.factory.getBean

	// create and configure beans
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

    // retrieve configured instance
    val service = context.getBean<PetStoreService>("petStore")

    // use configured instance
    var userList = service.getUsernameList()
----
======

With Groovy configuration, bootstrapping looks very similar. It has a different context
implementation class which is Groovy-aware (but also understands XML bean definitions).
The following example shows Groovy configuration:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")
----
======

The most flexible variant is `GenericApplicationContext` in combination with reader
delegates -- for example, with `XmlBeanDefinitionReader` for XML files, as the following
example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	GenericApplicationContext context = new GenericApplicationContext();
	new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
	context.refresh();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val context = GenericApplicationContext()
	XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
	context.refresh()
----
======

You can also use the `GroovyBeanDefinitionReader` for Groovy files, as the following
example shows:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	GenericApplicationContext context = new GenericApplicationContext();
	new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
	context.refresh();
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val context = GenericApplicationContext()
	GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
	context.refresh()
----
======

You can mix and match such reader delegates on the same `ApplicationContext`,
reading bean definitions from diverse configuration sources.

You can then use `getBean` to retrieve instances of your beans. The `ApplicationContext`
interface has a few other methods for retrieving beans, but, ideally, your application
code should never use them. Indeed, your application code should have no calls to the
`getBean()` method at all and thus have no dependency on Spring APIs at all. For example,
Spring's integration with web frameworks provides dependency injection for various web
framework components such as controllers and JSF-managed beans, letting you declare
a dependency on a specific bean through metadata (such as an autowiring annotation).




